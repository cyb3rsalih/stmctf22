# STMCTF'22 Final

## Soru İsmi:
`impersonation`

## Kategori:
- `Crypto`

## Soru:
```bash
$ python3 generate.py
Generating ECDSA parameters...
Curve: NIST384p
Hash Function: sha256
Public Key: 712518740487579662347512643008734219399028531312521045242833278776436152411929539211317906989373017206904948868324909192383248733285615147080063323449136151998649071857342593772864833108135692235860161098343908189222058255036593857
Signed message:
message-1
Signature:
108359373973517358056753387690910153133323687100077423209193715329563578908311014159307991491201156971798282038938010053387542905321005133233060838218302610331499014751886701762214196920935405919017458442333665591058101417533692542
Signed message:
message-2
Signature:
45347882901279554374116950966780230823769619289353794046827899833948100538606761563418279164978770913567821668433195870258692109350669554589511488528238768119020215419220878343488718879489769702228507004760937779392487951529211633
Signed message:
message-3
Signature:
53670982072315098698077458329641311434045342503576782660188889865730592413901496117636808158184962925245932868760477481370326595862693952984911467447553617420233545144556017092242988424648354760283447224399997500194801998574077962
Signed message:
message-4
Signature:
1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032403205417899937794396326575337400711123106559735075484612809824257935001763839
Signed message:
message-5
Signature:
118313162893444340787726089810457539408985871598493196874851111264745962008281182376023562099496792093476232910763707021016023181724566746498040989156033470788214337137164153600650650800925871854711619987685252546921983685172760779
Signed message:
message-6
Signature:
597258029735318939609606649961690043836451676268483084654487866272127272488989383134599748467736674038176766011531303839314459660875212264255888409790585740422153848006064813221575695599233181323352191872555451780366603017447927134
Signed message:
message-7
Signature:
1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032381334909320124192570521248775105694066666135246966186705019446919826707710870
$ curl -s 'http://impersonation.stmctf.com?m=message-1&s=108359373973517358056753387690910153133323687100077423209193715329563578908311014159307991491201156971798282038938010053387542905321005133233060838218302610331499014751886701762214196920935405919017458442333665591058101417533692542'
{"response":"message verified, change your message next time","flag":"S"}
$ curl -s 'http://impersonation.stmctf.com?m=message-2&s=45347882901279554374116950966780230823769619289353794046827899833948100538606761563418279164978770913567821668433195870258692109350669554589511488528238768119020215419220878343488718879489769702228507004760937779392487951529211633'
{"response":"message verified, change your message next time","flag":"T"}
$ curl -s 'http://impersonation.stmctf.com?m=message-3&s=53670982072315098698077458329641311434045342503576782660188889865730592413901496117636808158184962925245932868760477481370326595862693952984911467447553617420233545144556017092242988424648354760283447224399997500194801998574077962'
{"response":"message verified, change your message next time","flag":"M"}
$ curl -s 'http://impersonation.stmctf.com?m=message-4&s=1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032403205417899937794396326575337400711123106559735075484612809824257935001763839'
{"response":"message verified, change your message next time","flag":"C"}
$ curl -s 'http://impersonation.stmctf.com?m=message-5&s=118313162893444340787726089810457539408985871598493196874851111264745962008281182376023562099496792093476232910763707021016023181724566746498040989156033470788214337137164153600650650800925871854711619987685252546921983685172760779'
{"response":"message verified, change your message next time","flag":"T"}
$ curl -s 'http://impersonation.stmctf.com?m=message-6&s=597258029735318939609606649961690043836451676268483084654487866272127272488989383134599748467736674038176766011531303839314459660875212264255888409790585740422153848006064813221575695599233181323352191872555451780366603017447927134'
{"response":"message verified, change your message next time","flag":"F"}
$ curl -s 'http://impersonation.stmctf.com?m=message-7&s=1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032381334909320124192570521248775105694066666135246966186705019446919826707710870'
{"response":"message verified, change your message next time","flag":"{"}
```

---

## Çözüm:

* Soruda verilen imzalar incelendiğinde 'r' değerleri aynı olduğundan 'message-4' ve 'message-7' mesajları imzalanırken aynı rastgele değer kullanıldığı çıkarımı yapılır.

```python
# message-4
r|s(signature) =  1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032403205417899937794396326575337400711123106559735075484612809824257935001763839
r = 26247035095799689268623156744566981891852923491109213387815615900925518854738050089022388053975719786650872476732087
s = 26247035095799689268623156744566981891852923491109213387815615900925518854738050089022388053975719786650872476732087
```

```python
# message-7
r|s(signature) = 1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032381334909320124192570521248775105694066666135246966186705019446919826707710870
r = 26247035095799689268623156744566981891852923491109213387815615900925518854738050089022388053975719786650872476732087
s = 18355152451140634439936703154642677875045361191908630132565406872062255998522766714756090292289164967724690545705878
```

* 'r' ve  's' değerleri aşağıdaki kod yardımıyla bulunabilir.

```python
# imzanın 96 byte olduğu bilgisi,
# r ve s değerlerinin 48 byte olduğu bilgisi,
# imza algoritmasından gelmektedir.

# signature 4
s4 = 1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032403205417899937794396326575337400711123106559735075484612809824257935001763839
# signature 7
s7 = 1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032381334909320124192570521248775105694066666135246966186705019446919826707710870

s4_b = s4.to_bytes(96, 'big')
s7_b = s7.to_bytes(96, 'big')

r4_i = int.from_bytes(s4_b[:48], 'big')
s4_i = int.from_bytes(s4_b[48:], 'big')
r7_i = int.from_bytes(s7_b[:48], 'big')
s7_i = int.from_bytes(s7_b[48:], 'big')

print(f"r4: {r4_i}")
print(f"s4: {s4_i}")
print(f"r7: {r7_i}")
print(f"s7: {s7_i}")
```

* İmzalamada aynı rastgele değerin kullanılması ECDSA için zaafiyet ortaya çıkarır. Aşağıdaki kod yardımıyla bu durumdan yararlanılarak 'private key' değeri elde edilir.

```python
from ecdsa import SigningKey, VerifyingKey, NIST384p
from ecdsa.util import sigencode_string, sigdecode_string
from ecdsa.numbertheory import inverse_mod
from hashlib import sha256


def attack(publicKeyOrderInteger, signaturePair1, signaturePair2, messageHash1, messageHash2): 
    r1 = signaturePair1[0]
    s1 = signaturePair1[1]
    r2 = signaturePair2[0]
    s2 = signaturePair2[1]

    #Convert Hex into Int
    L1 = int(messageHash1, 16)
    L2 = int(messageHash2, 16)

    if (r1 != r2):
        print("ERROR: The signature pairs given are not susceptible to this attack")
        return None

    #A bit of Math 
    #L1 = Hash(message_1) 
    #L2 = Hash(message_2)
    #pk = Private Key (unknown to attacker)
    #R  = r1 == r2
    #K  = K value that was used (unknown to attacker)
    #N  = integer order of G (part of public key)
    
    #         From Signing Defintion
    #s1 = (L1 + pk * R) / K Mod N    and     s2 = (L2 + pk * R) / K Mod N
    
    #         Rearrange 
    #K = (L1 + pk * R) / s1 Mod N    and     K = (L2 + pk * R) / s2 Mod N
    
    #         Set Equal
    #(L1 + pk * R) / s1 = (L2 + pk * R) / s2     Mod N
    
    #         Solve for pk (private key)
    #pk Mod N = (s2 * L1 - s1 * L2) / R * (s1 - s2)
    #pk Mod N = (s2 * L1 - s1 * L2) * (R * (s1 - s2)) ** -1

    numerator = (((s2 * L1) % publicKeyOrderInteger) - ((s1 * L2) % publicKeyOrderInteger))
    denominator = inverse_mod(r1 * ((s1 - s2) % publicKeyOrderInteger), publicKeyOrderInteger)

    privateKey = numerator * denominator % publicKeyOrderInteger

    return privateKey

if __name__ == "__main__":
    ### PROOF OF CONCEPT ####

    #Messages to be signed
    message_4 = str("message-4")
    message_7 = str("message-7")

    #Get message Hash 
    messageHash4 = sha256(message_4.encode('utf-8')).hexdigest()
    messageHash7 = sha256(message_7.encode('utf-8')).hexdigest()

    pubkey = 712518740487579662347512643008734219399028531312521045242833278776436152411929539211317906989373017206904948868324909192383248733285615147080063323449136151998649071857342593772864833108135692235860161098343908189222058255036593857
    vk = VerifyingKey.from_string(pubkey.to_bytes(96, 'big'), curve=NIST384p, hashfunc=sha256)

    s4 = 1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032403205417899937794396326575337400711123106559735075484612809824257935001763839
    s7 = 1034185839481682719866415711672643620493012746459739913350434332196071816455295853885883906658640919608724392493385529135316175116191277083318748800593032381334909320124192570521248775105694066666135246966186705019446919826707710870
    signature4 = s4.to_bytes(96, 'big')
    signature7 = s7.to_bytes(96, 'big')

    r1, s1 = sigdecode_string(signature4, vk.pubkey.order)
    r2, s2 = sigdecode_string(signature7, vk.pubkey.order)

    #Start the attack
    privateKeyCalculation = attack(vk.pubkey.order, (r1,s1), (r2,s2), messageHash4, messageHash7)
    print(privateKeyCalculation)
```

* 'private key' değeri elde edildikten sonra aşağıdaki kod yardımıyla yeni mesajlar imzalanarak sunucuya gönderilir ve flag harf harf elde edilir.

```python
from ecdsa import SigningKey, VerifyingKey, NIST384p
from hashlib import sha256
import requests

messages = {}
sk = None
pk = 10913167908778904387090211371998477846706379076047823401337670663527369197045522305036880740365515128156889205574701
sk = SigningKey.from_string(pk.to_bytes(48, 'big'), curve=NIST384p, hashfunc=sha256)

flag = ""
for i in range(40):
    m = str(i)
    s = int.from_bytes(sk.sign(m.encode("utf-8"), k=1), 'big')
    req = requests.get(url="http://impersonation.stmctf.com", params={"m": m, "s": s})
    flag += req.json()["flag"]

print(flag)
```